#=========================================================================
# SimpleImportPass.py
#=========================================================================
# SimpleImportPass class imports a SystemVerilog source file back to a 
# PyMTL Component. It is meant to be used on files generated by 
# pymtl.passes.SystemVerilogTranslationPass. 
# 
# Author : Peitian Pan
# Date   : Oct 18, 2018

import os, re, sys, shutil, linecache

from pymtl            import *
from pymtl.passes     import BasePass, PassMetadata
from pymtl.passes.utility import collect_objs

from errors import *
from ExternalSimSetup import setup_external_sim
from PyMTLWrapperGen  import generate_py_wrapper
from helpers import get_struct_objects, gen_name_port_list, verilog_name

class SimpleImportPass( BasePass ):

  def __call__( s, model ):
    """Import a Verilog/SystemVerilog file. `model` is the PyMTL object
    to be imported."""

    try:
      model._pass_sverilog_translation.translated
      m_rtype = model._pass_structural_rtlir_gen.rtlir_type

    except AttributeError:
      raise PyMTLImportError( model.__class__.__name__,
        'the target model instance should be translated first!' 
      )

    model._pass_simple_import = PassMetadata()

    # Assume the input verilog file and the top module has the same name 
    # as the class name of model
    
    module_name = model._translator._top_module_name
    sv_name  = module_name
    ssg_name = module_name + '.ssg'
    top_name = module_name

    # Generate the interface structure

    ports = gen_name_port_list( m_rtype.get_ports_packed(),
      m_rtype.get_ifc_views() )
    unpacked_ports = gen_name_port_list( m_rtype.get_ports(),
      m_rtype.get_ifc_views() )

    port_objs = sorted(
      model.get_input_value_ports() | model.get_output_value_ports(),
      key = repr
    )

    # Setup verilator

    lib_name, port_cdefs = setup_external_sim( sv_name, top_name, ports )

    # Create a python wrapper that can access the verilated model

    py_wrapper_name = generate_py_wrapper(
      ports, unpacked_ports, top_name, lib_name, port_cdefs, ssg_name
    )

    py_wrapper = py_wrapper_name.split('.')[0]

    # Add CWD to sys.path so we can import from the wrappers

    if not os.getcwd() in sys.path:
      sys.path.append( os.getcwd() )

    linecache.checkcache()

    # Import the model from python wrapper

    if py_wrapper in sys.modules:
      # We are (probably) in a test process that is repeatedly run
      # Reloading is needed since the user may have updated the source file

      exec( "reload( sys.modules['{py_wrapper}'] )".format( **locals() ) )
      exec(
        "ImportedModel=sys.modules['{py_wrapper}'].{top_name}".format(**locals())
      )

    else:
      # First time execution
      import_cmd = \
        'from {py_wrapper} import {top_name} as ImportedModel'.format(
          py_wrapper = py_wrapper, top_name   = top_name,
        )
      exec( import_cmd )

    model._pass_simple_import.imported_model = ImportedModel()
    
    # Update the global namespace of `construct` so that the struct
    # classes defined previously can still be used in the imported model.
    # This is simple-import only because you must have the live
    # structs class, which is not possible in generic import.

    model._pass_simple_import.\
      imported_model.construct.__globals__.update(
        get_struct_objects( port_objs ) )

  def port_name_mangle( s, name ):
    attr_pos = name.find( '.' )
    if attr_pos == -1: return name
    assert attr_pos != len( name )-1, 'invalid port name {}'.format( name )
    return verilog_name( name[0:attr_pos] ) + '_' + name[attr_pos+1:]
