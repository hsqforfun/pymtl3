#=========================================================================
# RTLIR.py
#=========================================================================
# This file contains the definition of all RTLIR constructs.
# This file is automatically generated by RTLIRImplGen.py.

class BaseRTLIR( object ):
  def __init__( s ):
    pass

class CombUpblk( BaseRTLIR ):
  def __init__( s, name, body ):
    s.name = name
    s.body = body

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    if s.name != other.name:
      return False
    for x, y in zip( s.body, other.body ):
      if x != y:
        return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class SeqUpblk( BaseRTLIR ):
  def __init__( s, name, body ):
    s.name = name
    s.body = body

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    if s.name != other.name:
      return False
    for x, y in zip( s.body, other.body ):
      if x != y:
        return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class Assign( BaseRTLIR ):
  def __init__( s, target, value ):
    s.target = target
    s.value = value

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    if s.target != other.target:
      return False
    if s.value != other.value:
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class AugAssign( BaseRTLIR ):
  def __init__( s, target, op, value ):
    s.target = target
    s.op = op
    s.value = value

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    if s.target != other.target:
      return False
    if s.op != other.op:
      return False
    if s.value != other.value:
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class If( BaseRTLIR ):
  def __init__( s, cond, body, orelse ):
    s.cond = cond
    s.body = body
    s.orelse = orelse

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    if s.cond != other.cond:
      return False
    for x, y in zip( s.body, other.body ):
      if x != y:
        return False
    for x, y in zip( s.orelse, other.orelse ):
      if x != y:
        return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class For( BaseRTLIR ):
  def __init__( s, var, start, end, step, body ):
    s.var = var
    s.start = start
    s.end = end
    s.step = step
    s.body = body

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    if s.var != other.var:
      return False
    if s.start != other.start:
      return False
    if s.end != other.end:
      return False
    if s.step != other.step:
      return False
    for x, y in zip( s.body, other.body ):
      if x != y:
        return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class Number( BaseRTLIR ):
  def __init__( s, value ):
    s.value = value

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    if s.value != other.value:
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class Bitwidth( BaseRTLIR ):
  def __init__( s, nbits, value ):
    s.nbits = nbits
    s.value = value

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    if s.nbits != other.nbits:
      return False
    if s.value != other.value:
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class IfExp( BaseRTLIR ):
  def __init__( s, cond, body, orelse ):
    s.cond = cond
    s.body = body
    s.orelse = orelse

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    if s.cond != other.cond:
      return False
    if s.body != other.body:
      return False
    if s.orelse != other.orelse:
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class UnaryOp( BaseRTLIR ):
  def __init__( s, op, operand ):
    s.op = op
    s.operand = operand

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    if s.op != other.op:
      return False
    if s.operand != other.operand:
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class BoolOp( BaseRTLIR ):
  def __init__( s, op, values ):
    s.op = op
    s.values = values

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    if s.op != other.op:
      return False
    for x, y in zip( s.values, other.values ):
      if x != y:
        return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class BinOp( BaseRTLIR ):
  def __init__( s, left, op, right ):
    s.left = left
    s.op = op
    s.right = right

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    if s.left != other.left:
      return False
    if s.op != other.op:
      return False
    if s.right != other.right:
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class Compare( BaseRTLIR ):
  def __init__( s, left, op, right ):
    s.left = left
    s.op = op
    s.right = right

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    if s.left != other.left:
      return False
    if s.op != other.op:
      return False
    if s.right != other.right:
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class Attribute( BaseRTLIR ):
  def __init__( s, value, attr ):
    s.value = value
    s.attr = attr

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    if s.value != other.value:
      return False
    if s.attr != other.attr:
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class Index( BaseRTLIR ):
  def __init__( s, value, idx ):
    s.value = value
    s.idx = idx

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    if s.value != other.value:
      return False
    if s.idx != other.idx:
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class Slice( BaseRTLIR ):
  def __init__( s, value, lower, upper ):
    s.value = value
    s.lower = lower
    s.upper = upper

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    if s.value != other.value:
      return False
    if s.lower != other.lower:
      return False
    if s.upper != other.upper:
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class Base( BaseRTLIR ):
  def __init__( s, base ):
    s.base = base

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    if s.base != other.base:
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class LoopVar( BaseRTLIR ):
  def __init__( s, name ):
    s.name = name

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    if s.name != other.name:
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class FreeVar( BaseRTLIR ):
  def __init__( s, name, obj ):
    s.name = name
    s.obj = obj

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    if s.name != other.name:
      return False
    if s.obj != other.obj:
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class TmpVar( BaseRTLIR ):
  def __init__( s, name ):
    s.name = name

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    if s.name != other.name:
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class LoopVarDecl( BaseRTLIR ):
  def __init__( s, name ):
    s.name = name

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    if s.name != other.name:
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class Invert( BaseRTLIR ):
  def __init__( s ):
    pass

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class Not( BaseRTLIR ):
  def __init__( s ):
    pass

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class UAdd( BaseRTLIR ):
  def __init__( s ):
    pass

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class USub( BaseRTLIR ):
  def __init__( s ):
    pass

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class And( BaseRTLIR ):
  def __init__( s ):
    pass

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class Or( BaseRTLIR ):
  def __init__( s ):
    pass

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class Add( BaseRTLIR ):
  def __init__( s ):
    pass

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class Sub( BaseRTLIR ):
  def __init__( s ):
    pass

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class Mult( BaseRTLIR ):
  def __init__( s ):
    pass

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class Div( BaseRTLIR ):
  def __init__( s ):
    pass

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class Mod( BaseRTLIR ):
  def __init__( s ):
    pass

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class Pow( BaseRTLIR ):
  def __init__( s ):
    pass

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class ShiftLeft( BaseRTLIR ):
  def __init__( s ):
    pass

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class ShiftRightLogic( BaseRTLIR ):
  def __init__( s ):
    pass

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class BitAnd( BaseRTLIR ):
  def __init__( s ):
    pass

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class BitOr( BaseRTLIR ):
  def __init__( s ):
    pass

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class BitXor( BaseRTLIR ):
  def __init__( s ):
    pass

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class Eq( BaseRTLIR ):
  def __init__( s ):
    pass

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class NotEq( BaseRTLIR ):
  def __init__( s ):
    pass

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class Lt( BaseRTLIR ):
  def __init__( s ):
    pass

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class LtE( BaseRTLIR ):
  def __init__( s ):
    pass

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class Gt( BaseRTLIR ):
  def __init__( s ):
    pass

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

class GtE( BaseRTLIR ):
  def __init__( s ):
    pass

  def __eq__( s, other ):
    if type( s ) != type( other ):
      return False
    return True

  def __ne__( s, other ):
    return not s.__eq__( other )

#-------------------------------------------------------------------------
# RTLIR visitor
#-------------------------------------------------------------------------

class RTLIRNodeVisitor( object ):
  # This visitor uses the same code as the Python AST node visitor
  def visit( self, node, *args ):
    method = 'visit_' + node.__class__.__name__
    visitor = getattr( self, method, self.generic_visit )
    return visitor( node, *args )

  def generic_visit( self, node, *args ):
    for field in node.__dict__.keys():
      value = node.__dict__[ field ]
      if isinstance( value, list ):
        for item in value:
          if isinstance( item, BaseRTLIR ):
            self.visit( item, *args )
      elif isinstance( value, BaseRTLIR ):
        self.visit( value, *args )
